//**********************Intro***********************

The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.

A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason.

A Promise is in one of these states:

1. pending: initial state, neither fulfilled nor rejected.
2. fulfilled: meaning that the operation completed successfully.
3. rejected: meaning that the operation failed.

A pending promise can either be fulfilled with a value, or rejected with a reason (error). When either of these options happens, the associated handlers queued up by a promise's then method are called. (If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.)

As the Promise.prototype.then() and Promise.prototype.catch() methods return promises, they can be chained.


********************************Methods****************************
new Promise()

The constructor is primarily used to wrap functions that do not already support promises.


Promise.reject(reason)

Returns a new Promise object that is rejected with the given reason.


Promise.resolve(value)

Returns a new Promise object that is resolved with the given value. If the value is a thenable (i.e. has a then method), the returned promise will "follow" that thenable, adopting its eventual state; otherwise the returned promise will be fulfilled with the value.

N.B: if we don't use catch statement then it will throw `uncaught` error for rejection.


Promise.all(iterable)

Wait for all promises to be resolved, or for any to be rejected.
If the returned promise resolves, it is resolved with an aggregating array of the values from the resolved promises, in the same order as defined in the iterable of multiple promises.
If it rejects, it is rejected with the reason from the first promise in the iterable that was rejected.


Promise.allSettled(iterable)

Wait until all promises have settled (each may resolve or reject).
Returns a promise that resolves after all of the given promises have either resolved or rejected, with an array of objects that each describe the outcome of each promise.


Promise.race(iterable)

Wait until any of the promises is resolved or rejected.
If the returned promise resolves, it is resolved with the value of the first promise in the iterable that resolved.
If it rejects, it is rejected with the reason from the first promise that was rejected.


p.then(onFulfilled[, onRejected]);

The fulfillment of the promise is simply logged, via a fulfill callback and the rejection if it doesn't fulfill via a rejection callback using p1.then(). And p.then() method also can return a Promise like Promise constructor.

N.B: Promise constructor is resolved by calling resove() method and promise value is that resolved method's parameter. On the other hand p1.then() is resoved by returning something using fulfill callback so that other promise like p2.then() gets its resoved/returned value to be resoved.
i.e.

p.then((value) => {
  // fulfillment
}, (reason) => {
  // rejection
});


Example 01

let myFirstPromise = new Promise((resolve, reject) => {
  // We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.
  // In this example, we use setTimeout(...) to simulate async code.
  // In reality, you will probably be using something like XHR or an HTML5 API.
  setTimeout( function() {
    resolve("Success!")  // Yay! Everything went well!
  }, 250) 
}) 

myFirstPromise
.then((successMessage) => {
  // successMessage is whatever we passed in the resolve(...) function above.
  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.
  console.log("Yay! " + successMessage) 
});

// Expected result: Yay! Success!

let myFirstPromise = new Promise((resolve, reject) => {
  // We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.
  // In this example, we use setTimeout(...) to simulate async code.
  // In reality, you will probably be using something like XHR or an HTML5 API.
  setTimeout( function() {
    reject("Failure!")  // Yay! Everything went well!
  }, 250) 
});

myFirstPromise
.then((successMessage) => {
  // successMessage is whatever we passed in the resolve(...) function above.
  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.
  console.log("Yay! " + successMessage) 
})
.catch((failureMessage) => {
  console.log("Nope! " + failureMessage);
});

// Expected result: Nope! Failure!


// Example 02

let first = (val)=> {
  return val+2;
};
let second = (val)=> {
  return val+2;
};
let third = (val)=> {
  return val+2;
};

let promise = new Promise(function(resolve, reject) {
  resolve(2);
});

/*// ES2017
let promise = async function() {
  return 2;
};*/

let fulfilledPromise = promise.then(first).then(second).then(third).then(function(response) {
  console.log(response); // 8
});

console.log(promise); // Promise {<resolved>: 2}
console.log(promise.then(first).then(second).then(third)); // Promise {<resolved>: 8}, now we have to retrieve the resolved value from the promise object by using another then method or await keyword
console.log(fulfilledPromise); // Promise {<resolved>: undefined}, this is undefined because it doesn't return/resolve anything
console.log(await promise); // 2


// Example 03

function makeRequest(media){
  return new Promise((resolve, reject) => {
    console.log(`Making Request to ${media}`);
    if(media==='google'){
      resolve('Google says hi');
    } else {
      reject('We can only talk to Google');
    }
  });
}

function processRequest(response){
  return new Promise((resolve, reject) => {
    console.log('Processing response');
    resolve(`Extra Information + ${response}`);
  });
}

makeRequest('google').then(response => {
  console.log('Response Received');
  return processRequest(response);
}).then(processResponse=>{
  console.log(processResponse);
}).catch(err=>{
  console.log(err);
});

console.dir(makeRequest('google'));




























