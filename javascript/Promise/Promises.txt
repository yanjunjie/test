//**********************Intro***********************

The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.

A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason.

A Promise is in one of these states:

1. pending: initial state, neither fulfilled nor rejected.
2. fulfilled: meaning that the operation completed successfully.
3. rejected: meaning that the operation failed.

A pending promise can either be fulfilled with a value, or rejected with a reason (error). When either of these options happens, the associated handlers queued up by a promise's then method are called. (If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.)

As the Promise.prototype.then() and Promise.prototype.catch() methods return promises, they can be chained.


********************************Methods****************************
new Promise()

The constructor is primarily used to wrap functions that do not already support promises.


Promise.reject(reason)

Returns a new Promise object that is rejected with the given reason.


Promise.resolve(value)

Returns a new Promise object that is resolved with the given value. If the value is a thenable (i.e. has a then method), the returned promise will "follow" that thenable, adopting its eventual state; otherwise the returned promise will be fulfilled with the value.

N.B: if we don't use catch statement then it will throw `uncaught` error for rejection.

Example

const promise1 = Promise.resolve(3);
promise1.then(result => console.log(result));


Promise.all(iterable)

To execute parallelly all the promises/tasks at the same time. The Promise. all() method returns a single Promise that fulfills when all of the promises passed as an iterable. It rejects with the reason of the first promise that rejects.

It is typically used after having started multiple asynchronous tasks to run concurrently and having created promises for their results so that one can't wait for another to complete and all the tasks are being finished together. Finally it returns a promise.
Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all

Example 01

const promise1 = Promise.resolve(3);
const actualValue2 = 42;
const promise3 = new Promise(function(resolve, reject) {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, actualValue2, promise3]).then(function(values) {
  console.log(values); // expected output: Array [3, 42, "foo"]
});


Example 1.1.0: If the iterable contains non-promise values, they will be ignored. But the evaluation will be done asynchronously. So it gets fulfilled

const actualValue1 = 3
const actualValue2 = 42;
const actualValue3 = "foo"

Promise.all([promise1, promise2, promise3]).then(function(values) {
  console.log(values);
});
// expected output: Array [3, 42, "foo"]


Example 02

let p = Promise.all([1,2,3]);
let p2 = Promise.all([1,2,3, Promise.resolve(444)]);
let p3 = Promise.all([1,2,3, Promise.reject(555)]);

// using setTimeout we can execute code after the stack is empty
setTimeout(function() {
    console.log(p);
    console.log(p2);
    console.log(p3);
});

// logs (Firefox)
// Promise { <state>: "fulfilled", <value>: Array[3] }
// Promise { <state>: "fulfilled", <value>: Array[4] }
// Promise { <state>: "rejected", <reason>: 555 }


Example 03

var p1 = new Promise((resolve, reject) => { 
  setTimeout(() => resolve('p1_delayed_resolution'), 1000); 
}); 

var p2 = new Promise((resolve, reject) => {
  reject(new Error('p2_immediate_rejection'));
});

Promise.all([
  p1.catch(error => { return error }),
  p2.catch(error => { return error }),
]).then(values => { 
  console.log(values[0]) // "p1_delayed_resolution"
  console.error(values[1]) // "Error: p2_immediate_rejection"
})


Promise.race(iterable)

Wait until one of the promises is resolved or rejected.
If the returned promise resolves, it is resolved with the value of the first promise in the iterable that resolved.
If it rejects, it is rejected with the reason from the first promise that was rejected.

Example 

const promise1 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 200, 'one'); // resolve and reject both are promise methods so either we can make a callback or call a method
});

const str = 'two'
const promise2 = new Promise(function(resolve, reject) {
    setTimeout(() => resolve(str), 100, str);
});

const promise3 = new Promise(function(resolve, reject) {
    setTimeout(resolve('three'), 50);
});

Promise.race([promise1, promise2, promise3]).then(function(value) {
  console.log(value);
  // all resolve, but promise3 is faster
});

// expected output: "three"


Promise.allSettled(iterable)

Wait until all promises have settled (each may resolve or reject).
Returns a promise that resolves after all of the given promises have either resolved or rejected, with an array of objects that each describe the outcome of each promise.


p.then(onFulfilled[, onRejected]);

The fulfillment of the promise is simply logged, via a fulfill callback and the rejection if it doesn't fulfill via a rejection callback using p1.then(). And p.then() method also can return a Promise like Promise constructor.

N.B: Promise constructor is resolved by calling resove() method and promise value is that resolved method's parameter. On the other hand p1.then() is resoved by returning something using fulfill callback so that other promise like p2.then() gets its resoved/returned value to be resoved.
i.e.

p.then((value) => {
  // fulfillment
}, (reason) => {
  // rejection
});


Example 01

let myFirstPromise = new Promise((resolve, reject) => {
  // We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.
  // In this example, we use setTimeout(...) to simulate async code.
  // In reality, you will probably be using something like XHR or an HTML5 API.
  setTimeout( function() {
    resolve("Success!")  // Yay! Everything went well!
  }, 250) 
}) 

myFirstPromise
.then((successMessage) => {
  // successMessage is whatever we passed in the resolve(...) function above.
  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.
  console.log("Yay! " + successMessage) 
});

// Expected result: Yay! Success!

let myFirstPromise = new Promise((resolve, reject) => {
  // We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.
  // In this example, we use setTimeout(...) to simulate async code.
  // In reality, you will probably be using something like XHR or an HTML5 API.
  setTimeout( function() {
    reject("Failure!")  // Yay! Everything went well!
  }, 250) 
});

myFirstPromise
.then((successMessage) => {
  // successMessage is whatever we passed in the resolve(...) function above.
  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.
  console.log("Yay! " + successMessage) 
})
.catch((failureMessage) => {
  console.log("Nope! " + failureMessage);
});

// Expected result: Nope! Failure!


// Example 02

let first = (val)=> {
  return val+2;
};
let second = (val)=> {
  return val+2;
};
let third = (val)=> {
  return val+2;
};

let promise = new Promise(function(resolve, reject) {
  resolve(2);
});

/*// ES2017
let promise = async function() {
  return 2;
};*/

let fulfilledPromise = promise.then(first).then(second).then(third).then(function(response) {
  console.log(response); // 8
});

console.log(promise); // Promise {<resolved>: 2}
console.log(promise.then(first).then(second).then(third)); // Promise {<resolved>: 8}, now we have to retrieve the resolved value from the promise object by using another then method or await keyword
console.log(fulfilledPromise); // Promise {<resolved>: undefined}, this is undefined because it doesn't return/resolve anything
console.log(await promise); // 2


// Example 03

function makeRequest(media){
  return new Promise((resolve, reject) => {
    console.log(`Making Request to ${media}`);
    if(media==='google'){
      resolve('Google says hi');
    } else {
      reject('We can only talk to Google');
    }
  });
}

function processRequest(response){
  return new Promise((resolve, reject) => {
    console.log('Processing response');
    resolve(`Extra Information + ${response}`);
  });
}

makeRequest('google').then(response => {
  console.log('Response Received');
  return processRequest(response);
}).then(processResponse=>{
  console.log(processResponse);
}).catch(err=>{
  console.log(err);
});

console.dir(makeRequest('google'));




























